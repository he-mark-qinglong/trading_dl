//@version=6  
indicator("多周期双边策略", overlay=true, max_bars_back=2000, max_boxes_count = 5000, max_lines_count = 500, max_polylines_count = 100)  

ohlc5 = close

f_delta_vpvr_vwap_center(_src, _open, _close, volLog, _length, _bins, _pct, _decay) =>
    // 2) 计算价格区间
    float lowv    = ta.lowest(_src, _length)
    float highv   = ta.highest(_src, _length)
    float binsize = math.max((highv - lowv) / _bins, 1e-8)
    // 3) 初始化累积数组
    var float[] accum = array.new_float(_bins, 0.0)
    for i = 0 to _bins - 1
        array.set(accum, i, 0.0)
    // 4) 按 bin 累计有向 log‐vol
    for j = 0 to _length - 1
        volj     = volLog[j]
        pricej   = _src[j]
        openj    = _open[j]
        closej   = _close[j]
        deltaj   = closej > openj ? volj : closej < openj ? -volj : 0.0
        bini     = math.floor((_bins - 1) * (pricej - lowv) / math.max(highv - lowv, 1e-8))
        bini     := math.max(0, math.min(_bins - 1, bini))
        weightj  = math.pow(_decay, _length - 1 - j)
        array.set(accum, bini, array.get(accum, bini) + math.abs(deltaj) * weightj)
    // 5) 计算 total_delta
    total_delta = 0.0
    for i = 0 to _bins - 1
        total_delta += array.get(accum, i)
    // 6) 找最大 bin 并扩展至 pct
    float result = na
    if total_delta > 0
        maxv       = -1.0
        center_idx = 0
        for i = 0 to _bins - 1
            v = array.get(accum, i)
            if v > maxv
                maxv := v
                center_idx := i
        sum_delta = array.get(accum, center_idx)
        left_idx  = center_idx
        right_idx = center_idx
        while sum_delta < total_delta * _pct
            add_l = left_idx > 0          ? array.get(accum, left_idx - 1)  : -1.0
            add_r = right_idx < _bins - 1 ? array.get(accum, right_idx + 1) : -1.0
            if add_l >= add_r and left_idx > 0
                left_idx -= 1
                sum_delta += array.get(accum, left_idx)
            else if right_idx < _bins - 1
                right_idx += 1
                sum_delta += array.get(accum, right_idx)
            else
                break
        // 7) 计算中轨 VWAP
        wsum  = 0.0
        pvsum = 0.0
        for i = left_idx to right_idx
            v      = array.get(accum, i)
            pricei = lowv + binsize * (i + 0.5)
            wsum  += v
            pvsum += v * pricei
        result := wsum != 0 ? pvsum / wsum : na
    result
// 从最外边界往内累积成交量到_pct，再用该区间计算量价均价
f_vpvr_pct_band_outer_in(_src, volLog, _length, _bins, _pct, _decay, _vwap, _low) =>
    // 2) 价格区间
    float lowv    = ta.lowest(_src, _length)
    float highv   = ta.highest(_src, _length)
    float binsize = math.max((highv - lowv) / _bins, 1e-8)
    // 3) 初始化各 bin 累积量
    var float[] accum = array.new_float(_bins, 0.0)
    for i = 0 to _bins - 1
        array.set(accum, i, 0.0)
    // 4) 按 log‐vol（大于均值才累积）加权填入各 bin
    float vmean = 0.0
    for j = 0 to _length - 1
        vmean += volLog[j]
    vmean := vmean / _length
    for j = 0 to _length - 1
        volj = volLog[j]
        if volj > vmean
            pricej  = _src[j]
            weightj = math.pow(_decay, _length - 1 - j)
            bini    = math.floor((_bins - 1) * (pricej - lowv) / math.max(highv - lowv, 1e-8))
            bini    := math.max(0, math.min(_bins - 1, bini))
            array.set(accum, bini, array.get(accum, bini) + volj * weightj)
    // 5) 计算总量
    total_vol = 0.0
    for i = 0 to _bins - 1
        total_vol += array.get(accum, i)
    // 6) 从边界往内累积到_pct
    float res = na
    if total_vol > 0
        float threshold = total_vol * _pct
        int start_i = 0
        int end_i = 0
        float cum = 0.0
        if _low
            // 从最低 bin(0) 往上累积
            idx = 0
            while idx < _bins and cum < threshold
                cum += array.get(accum, idx)
                idx += 1
            start_i := 0
            end_i   := math.min(_bins - 1, idx - 1)
        else
            // 从最高 bin(_bins-1) 往下累积
            idx = _bins - 1
            while idx >= 0 and cum < threshold
                cum += array.get(accum, idx)
                idx -= 1
            start_i := math.max(0, idx + 1)
            end_i   := _bins - 1
        // 7) 量价加权均价
        float wsum = 0.0
        float pvsum = 0.0
        for i = start_i to end_i
            v      = array.get(accum, i)
            pricei = lowv + binsize * (i + 0.5)
            wsum  += v
            pvsum += v * pricei
        res := wsum > 0 ? pvsum / wsum : na
    res

f_is_real_vol_breakout(_close, _upper, _lower, _volume, _v_array, _vol_mult) =>
    N = array.size(_v_array)
    vmean = array.sum(_v_array) / N
    is_up = _close > _upper and _volume > vmean * _vol_mult
    is_down = _close < _lower and _volume > vmean * _vol_mult
    is_up or is_down

smooth_sf_len = input.int(9, "超级平滑周期")

current_tf = timeframe.period

// ========== HFrame 设置 ==========  
wk_multiplier = 5
hfm_multiplier = 14
m_multipliyer = 30
// VP参数  
LFrame_vpLen = input.int(24, "Low VP周期") 
// HFrame_vpLen = input.int(24 * wk_multiplier, "High VP周期")  
SFrame_vpLen = input.int(24 * hfm_multiplier, "Super VP周期")  

// ====== 参数定义 ======
bins = input.int(50,  "分桶数(价格粒度)")


// 当前UTC时间：小时、分钟
// === 夏令时判断（略优于上述版本，保证周日处理准确） ===
cur_year  = year(time, "UTC")
cur_month = month(time, "UTC")
cur_day   = dayofmonth(time, "UTC")
cur_dow   = dayofweek(time, "UTC") // Pine: 1=Monday, 7=Sunday

march_1st_dow = dayofweek(timestamp(cur_year, 3, 1, 0, 0))
march_2nd_sunday = 1 + ((7 - march_1st_dow + 1) % 7) + 7
nov_1st_dow = dayofweek(timestamp(cur_year, 11, 1, 0, 0))
nov_1st_sunday = 1 + ((7 - nov_1st_dow + 1) % 7)

is_dst = ((cur_month > 3 and cur_month < 11) or (cur_month == 3 and cur_day >= march_2nd_sunday) or (cur_month == 11 and cur_day < nov_1st_sunday))
us_open_hour = is_dst ? 13 : 14     // UTC 美东上班9点
us_close_hour = is_dst ? 22 : 23    // UTC 美东下班18点

// === 当前UTC分钟 ===
cur_hh = hour(time, "UTC")
cur_mm = minute(time, "UTC")
cur_minute = cur_hh * 60 + cur_mm

// === 分段点（分钟制）===
asia_open_min  = 1 * 60   // 01:00 UTC
asia_close_min = 10 * 60  // 10:00 UTC
us_open_min   = us_open_hour * 60     // 13:00 or 14:00
us_close_min  = us_close_hour * 60    // 22:00 or 23:00

// === 段落判断 ===
is_asia_time = cur_minute >= asia_open_min and cur_minute < us_open_min  //asia_close_min
is_us_time   = cur_minute >= us_open_min and cur_minute < asia_open_min //us_close_min


// 1) 预计算 log‐vol
volLog = math.log(volume + 1)
sigma_3 = 99.73/100
sigma_2 = 95.45/100
sigma_1 = 68.27/100
float LFrame_vpPOC = bar_index > LFrame_vpLen  ? f_delta_vpvr_vwap_center(ohlc5, open, close, volLog, LFrame_vpLen, bins, sigma_3, 0.93) : na
// float HFrame_vpPOC = bar_index > HFrame_vpLen  ? f_delta_vpvr_vwap_center(ohlc5, open, close, volLog, HFrame_vpLen, bins, sigma_3, 0.95)  : na
float SFrame_vpPOC = bar_index > SFrame_vpLen  ? f_delta_vpvr_vwap_center(ohlc5, open, close, volLog, SFrame_vpLen, bins, sigma_3, 0.97)  : na



// ========== 可视化绘制 ==========  
// LFrame_vpPOC := ta.rma(LFrame_vpPOC, int(smooth_sf_len/2))

plot(LFrame_vpPOC, title="LFrame POC (时间加权)", color=color.new(color.yellow, 50), style=plot.style_line, linewidth=1)  


// HFrame_vpPOC := ta.rma(HFrame_vpPOC, int(smooth_sf_len/2))
// plot(HFrame_vpPOC,
//      color=is_asia_time ? color.green : is_us_time ? color.red : color.purple, 
//      linewidth=2, 
//      title="HFrame POC（绿=亚欧, 红=美盘）")



SFrame_vpPOC := ta.rma(SFrame_vpPOC, smooth_sf_len)
plot(SFrame_vpPOC, title="SFrame_vpPOC 中轨",
     color=is_asia_time ? color.new(color.blue, 20) : is_us_time ? color.new(color.yellow, 20) : color.new(color.white, 20), 
     style=plot.style_line, linewidth=4)




// HFrame_upPOC = bar_index > HFrame_vpLen  ? f_vpvr_pct_band_outer_in(high, volLog, HFrame_vpLen, bins, (1 - sigma_3)/2, 0.994, HFrame_vpPOC, false) : na
// HFrame_downPOC = bar_index > HFrame_vpLen  ? f_vpvr_pct_band_outer_in(low, volLog, HFrame_vpLen, bins, (1 - sigma_3)/2, 0.994, HFrame_vpPOC, true) : na

// 计算偏离 HFrame_vpPOC 5% 的上下边界
// HFrame_upPOC := bar_index > HFrame_vpLen ? HFrame_vpPOC * 1.07 : na
// HFrame_downPOC := bar_index > HFrame_vpLen ? HFrame_vpPOC * 0.93 : na

//百分比差
// h_delta_pct  = math.abs(close - close[HFrame_vpLen]) / close[HFrame_vpLen]

// plot(HFrame_upPOC, title="HFrame_upPOC", color=color.new(color.silver, 30), linewidth=3)  
// plot(HFrame_downPOC, title="HFrame_downPOC", color=color.new(color.silver, 30), linewidth=3)  


// SFrame_upPOC = bar_index > SFrame_vpLen  ? f_vpvr_pct_band_outer_in(close, volLog, SFrame_vpLen, bins, (1 - sigma_3)/2, 0.995, SFrame_vpPOC, false) : na
// SFrame_downPOC = bar_index > SFrame_vpLen  ? f_vpvr_pct_band_outer_in(close, volLog, SFrame_vpLen, bins, (1 - sigma_3)/2, 0.995, SFrame_vpPOC, true) : na
SFrame_upPOC = SFrame_vpPOC * (1 + 0.01)
SFrame_downPOC = SFrame_vpPOC * (1 - 0.01)
//百分比差
s_delta_pct  = math.abs(close - close[SFrame_vpLen]) / close[SFrame_vpLen]

// SFrame_upPOC := ta.rma(SFrame_upPOC, smooth_sf_len)
// SFrame_downPOC := ta.rma(SFrame_downPOC, smooth_sf_len)

// SFrame_upPOC := SFrame_upPOC * (1 + s_delta_pct * 0.075)
// SFrame_downPOC := SFrame_downPOC * (1 - s_delta_pct * 0.075)




var float[] v_array = na
if bar_index > SFrame_vpLen
    if na(v_array)
        v_array := array.new_float()
    array.unshift(v_array, volume)
    if array.size(v_array) > SFrame_vpLen 
        array.pop(v_array)

vol_mult = 3   // 2倍投入量

bool is_break = bar_index > SFrame_vpLen ? f_is_real_vol_breakout(close, SFrame_upPOC, SFrame_downPOC, volume, v_array, vol_mult) : false

plot(SFrame_upPOC, title="SFrame_upPOC", color=is_break ? color.new(color.green, 10) : color.new(color.white, 20), linewidth=4)  
plot(SFrame_downPOC, title="SFrame_downPOC", color=is_break ? color.new(color.red, 10) : color.new(color.white, 20), linewidth=4)  
// —— 分时段 Box + 每段上下静/动 Label 切片 ——

// —— 状态变量 —— 
var int    prevSess         = 0        // 0=none,1=asia,2=us,3=other
var int    startBar         = na
var float  startVal         = na
var float  sessHigh         = na
var float  sessLow          = na
var box    curBox           = na

// —— 本时段累加量 —— 
var float  sessionLongVol   = 0.0
var float  sessionShortVol  = 0.0

// —— 当前 session 动态 Label —— 
var label  lblTop           = na
var label  lblBottom        = na
// —— 本根 Bar 属于哪个时段 —— 
currSess = is_asia_time ? 1 : is_us_time ? 2 : 3
oneK = 1000

// —— 第 1 根 Bar 或 新时段 初始化 —— 
if barstate.isfirst
    prevSess        := currSess
    startBar        := bar_index
    sessHigh        := close  //high
    sessLow         := close  //low
    sessionLongVol  := 0.0
    sessionShortVol := 0.0
    curBox          := box.new(left=bar_index, right=bar_index, top=high, bottom=low,
                               bgcolor=color.new(color.gray,80), border_width=0)


// —— 时段切换：画历史 Box + 上下静态 Label + 删除动态 Label + 重置 —— 
else if currSess != prevSess
    // 1) 画上一个时段的静态 Box
    endBar = bar_index - 1
    colPrev = sessionLongVol > sessionShortVol ? color.new(color.blue,80) : sessionShortVol > sessionLongVol ? color.new(color.yellow,80) :color.new(color.white,80)
    box.new(left=startBar, right=endBar, top=sessHigh, bottom=sessLow, bgcolor=colPrev, border_width=0)
    
    // 3) 删除当前 session 的动态 Label
    if not na(lblTop)
        label.delete(lblTop)
    if not na(lblBottom)
        label.delete(lblBottom)

    // 4) 重置为新时段
    startBar        := bar_index
    sessHigh        := high
    sessLow         := low
    sessionLongVol  := 0.0
    sessionShortVol := 0.0
    curBox          := box.new(left=bar_index, right=bar_index, top=high, bottom=low, bgcolor=color.new(color.gray,80), border_width=0)

    prevSess := currSess



// —— 同一时段内：更新 High/Low、累加触及量、更新 Box & 动态 Label & 背景色 —— 
if currSess == prevSess
    // 更新段内极值
    sessHigh := math.max(sessHigh, high)
    sessLow  := math.min(sessLow,  low)

    // 累加“触及上轨/下轨”的成交量
    if not na(SFrame_upPOC)   and high >= SFrame_upPOC
        sessionLongVol  += volume
    if not na(SFrame_downPOC) and low  <= SFrame_downPOC
        sessionShortVol += volume

    // 决定颜色
    dynCol = sessionLongVol > sessionShortVol ? color.new(color.blue,80) : sessionShortVol > sessionLongVol ? color.new(color.yellow,80) : color.new(color.white,80)

    // 更新 Box
    box.set_right(curBox,   bar_index)
    box.set_top(curBox,     sessHigh)
    box.set_bottom(curBox,  sessLow)
    box.set_bgcolor(curBox, dynCol)

    // 删除上一根的动态 Label
    if not na(lblTop)
        label.delete(lblTop)
    if not na(lblBottom)
        label.delete(lblBottom)

    // 画新的动态 Label（紧贴 Box 上下沿）
    lblTop := label.new(bar_index, sessHigh, "LVol=" + str.tostring(math.round(sessionLongVol/oneK, 1)) + "K", xloc.bar_index, yloc.price, style=label.style_label_down, textcolor=color.green, color=color.new(color.black,80), size=size.normal)
    lblBottom := label.new(bar_index, sessLow, "SVol=" + str.tostring(math.round(sessionShortVol/oneK, 1)) + "K", xloc.bar_index, yloc.price, style=label.style_label_up, textcolor=color.red, color=color.new(color.black,80), size=size.normal)
